# 寄存器

- 段寄存器	CS DS SS ES
- 通用寄存器	16位:AX BX CX DX	32位:EAX
- 指令指针寄存器	IP
- 标志寄存器	
- 控制寄存器CR(control register)0-3	CR0 CR1 CR2 CR3 CR4



> 实模式下的地址线是 20 位,寻址空间多少?

20条线,即最大能表示2^20-1 = 1048575,寻址范围为0x00000~0xFFFFF(范围为1048576 = 1024*1024),

结合16位寄存器,可以实现1MB的寻址范围:

​	16 bits 的程序计数器首先从存储器中取得指令放入8 bits 的指令寄存器。

​	指令寄存器暂存放入的指令然后交给译码器取进行解析。

​	指令译码器将解析后的命令交给控制逻辑部件去执行操作。

​	我们知道存储器的内部结构是以字节形式组织的，所以cpu每次只能取得一条指令然后执行，接着重复上述操作，直至所有指令全部执行完毕。

​	这就是早期的串行结构设计。

-----

# 一些指令

- 启动bochs `../bin/bochs -f bochsrc.disk`



- 编译mbr `nasm -o mbr.bin mbr.s`
- 编译mbr,并指定库目录 `nasm -I include/ -o mbr.bin mbr.s`
- 写mbr入硬盘 `dd if=./mbr.bin of=./hd60M.img bs=512 count=1 conv=notrunc`



- 指定库编译loader `nasm -I include/ -o loader.bin loader.s`
- 写loader入硬盘 `dd if=./loader.bin of=./hd60M.img bs=512 count=4 seek=2 conv=notrunc`

----

# 实验三分析

## 一 

> 用BIOS中断打印字符串

![img](https://img-blog.csdnimg.cn/65a5d5b5c3fb43f891236d72070cc048.png)

- 存放BIOS程序的ROM空间被映射到实模式下1MB内存的顶部，即地址0xF0000-0xFFFFF处，共64KB,其中顶部的**0xFFFF0~0xFFFFF**这16B空间是BIOS程序的入口地址

- 开机后CS:IP值，其值是0x0000:0x0000,指令地址就是**0x0000**。

  在实模式下CPU访问的内存是段地址+偏移地址的方式来实现的,所以0xF000:0xFFF0,访问的地址是**0xF000*16+0xFFF0=0xFFFF0**(20位地址线)

  BIOS程序开始运行

  1. 检测和初始化硬件；
  2. 建立中断向量表（即硬件I/O的操作）
  3. 校验启动盘中位于0盘0道1扇区(**其实是0扇区**)的内容（检测到末尾的两个字节分别是`0x55`和`0xaa`时，就认为该扇区存放MBR）

- 此代码通过改变寄存器的值,对应的调用多次INT 10H中断函数,来达到打印相应字符串的结果

- MBR只能放在0盘0道1扇区,去掉最后的两字节识别信息,实际上MBR只有510字节大小,它其实是不能胜任加载操作系统的工作的,而其实MBR的任务是加载loader,由loader加载操作系统

```assembly
;主引导程序 
;------------------------------------------------------------
SECTION MBR vstart=0x7c00	;0x7c00是mbr的入口地址         
   mov ax,cs	;ax=0x0000
   mov ds,ax	;ds=0x0000
   mov es,ax	;es=0x0000
   mov ss,ax	;ss=0x0000
   mov fs,ax	;fs=0x0000
   mov sp,0x7c00	;sp=0x7c00 初始栈顶指针

; 清屏 利用0x06号功能，上卷全部行，则可清屏。
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷的行数(如果为0,表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值：
   mov     ax, 0x600	;ax=0x0600	清屏范围,也就是宽度
   mov     bx, 0x700	;bx=0x0700
   mov     cx, 0        ;cx=0x0000	左上角: (0, 0)
   mov     dx, 0x184f	;dx=0x184f	右下角: (80,25),
			   ; VGA文本模式中,一行只能容纳80个字符,共25行。
			   ; 下标从0开始,所以0x18=24,0x4f=79
   int     0x10            ; int 0x10

;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
;.get_cursor获取当前光标位置,在光标位置处打印字符.
   mov ah, 3	;ah=0x03 ax=0x0300	输入: 3号子功能是获取光标位置,需要存入ah寄存器
   mov bh, 0	;bh=0x00 bx=0x0000	bh寄存器存储的是待获取光标的页号

   int 0x10		; 输出: ch=光标开始行(0x00),cl=光标结束行(0x00)
			; dh=光标所在行号(0x18),dl=光标所在列号(0x4f)

;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

;;;;;;;;;     打印字符串    ;;;;;;;;;;;
   ;还是用10h中断,不过这次是调用13号子功能打印字符串
   mov ax, message	;ax=message	ax保存字符串地址
   mov bp, ax	;bp=message 保存字符串地址 es:bp 为串首地址, es此时同cs一致(0xF000)，
			; 开头时已经为es初始化

   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
   mov cx, 5		;cx=0x0005	保存字符串长度 cx 为串长度,不包括结束符0的字符个数
   mov ax, 0x1301	; 子功能号13是显示字符及属性,要存入ah寄存器,
			; al设置写字符方式 al=01: 显示字符串,光标跟随移动
   mov bx, 0x2		;bx=0x0002	bh(0x00)存储要显示的页号,此处是第0页,
			; bl(0x02)中是字符属性, 属性黑底绿字(bl = 02h)
   int 0x10		; 执行BIOS 0x10 号中断
   
;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

   jmp $		; 使程序悬停在此

   message db "1 MBR"
   times 510-($-$$) db 0 ; 填充剩余的510字节的空间为0
   db 0x55,0xaa   ;mbr结束标志,为了让bios辨认

```

- 代码开头`vstart=0x7c00`的原因,是由于它本身在`0x7c00`加载编译

![image-20230613103202585](assets/image-20230613103202585.png)

----

## 二

> 让MBR使用显卡打印字符串

<img src="assets/image-20230514115719185.png" alt="image-20230514115719185" style="zoom:150%;" />

![在这里插入图片描述](https://img-blog.csdnimg.cn/900147247d9549899a451bac1d4b4bd2.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/b72f5f991a334e62b867dea4e4effea9.png)

```assembly
;主引导程序 
;
;LOADER_BASE_ADDR equ 0xA000 
;LOADER_START_SECTOR equ 0x2
;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00
   mov ax,0xb800
   mov gs,ax

; 清屏
;利用0x06号功能，上卷全部行，则可清屏。
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷的行数(如果为0,表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值：
   mov     ax, 0600h
   mov     bx, 0700h
   mov     cx, 0               ; 左上角: (0, 0)
   mov     dx, 184fh	       ; 右下角: (80,25),
			       ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
			       ; 下标从0开始，所以0x18=24,0x4f=79
   int     10h                 ; int 10h 清屏操作

   ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
   mov byte [gs:0x00],'1'
   mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色

   mov byte [gs:0x02],' '
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],'M'
   mov byte [gs:0x05],0xA4   

   mov byte [gs:0x06],'B'
   mov byte [gs:0x07],0xA4

   mov byte [gs:0x08],'R'
   mov byte [gs:0x09],0xA4

   jmp $		       ; 通过死循环使程序悬停在此

   times 510-($-$$) db 0	; 填充剩余的510字节的空间为0
   db 0x55,0xaa

```

![image-20230612211653353](assets/image-20230612211653353.png)

-----

## 三

> 让MBR使用硬盘,并启动内核加载器loader

<img src="assets/image-20230514115957121.png" alt="image-20230514115957121" style="zoom:150%;" />



**每个扇区有512字节**

![指令](https://img-blog.csdnimg.cn/17bbd2f171a14b928c1da8846bd2b7cf.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/036d21fd504a4e748f3517fdd4871da9.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f1fe5142cec46abbe11dcb03470268d.png)

本实验约定的操作顺序如下：

1. 先选择通道，往该通道的 sector count 寄存器中写入**待操作的扇区数**。
2. 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
3. 往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为1 ，使其为 LBA 模式，设置第 4位，选择操作的硬盘（ master 硬盘或 slave 硬盘）。
4. 往该通道上的 command 寄存器写入操作命令。
5. 读取该通道上的 status 寄存器，判断硬盘工作是否完成。
6. 如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
7. 将硬盘数据读出。

> 剖析mbr.S代码
>

**1、代码功能**

从磁盘中加载操作系统的loader，该loader由我们自己写入磁盘

**2、实现原理**

计算机发展到现在，已经将对磁盘的种种操作，简化成了对磁盘暴露在外的寄存器的操作，对这些寄存器的操作需要通过in与out指令

**3、代码逻辑**

A、清屏

B、通过对内存特定区域的操作显示字符

C、从磁盘特定区域读取特定大小的数据到特定内存位置中

**4、怎么写代码？**

A、include boot.inc，这里面定义了loader在磁盘中的位置（我们会将其写入磁盘2号扇区），与loader加载进入内存后将要存放的位置（在第二章的内存布局图中，找一个靠前的可用位置就行了，本代码用的是0x900）

B、定义vstart=0x7c00，调用bios中断清屏，对特定内存区域放入数据来显示字符

C、按照与磁盘打交道的7个步骤来完成从磁盘取出数据存放到内存指定区域（这7个步骤就是用in与out操作特定通道的寄存器）

E、跳转到内存中的loader位置执行

F、填充MBR要求的510字节剩下的0，定义MBR要求的标准结尾0x55，0xaa



(boot/include/boot.inc)

```assembly
;boot.inc
;-------------  loader 和 kernel  ----------------
LOADER_BASE_ADDR equ 0x900		;CHS地址
LOADER_START_SECTOR equ 0x2		;LBA地址
```

mbr.s

```assembly
;主引导程序 mbr.s
;------------------------------------------------------------
%include "boot.inc"
SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00
   mov ax,0xb800
   mov gs,ax

; 清屏
;利用0x06号功能，上卷全部行，则可清屏。
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷的行数(如果为0,表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值：
   mov     ax, 0600h
   mov     bx, 0700h
   mov     cx, 0                   ; 左上角: (0, 0)
   mov     dx, 184fh		   ; 右下角: (80,25),
				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				   ; 下标从0开始，所以0x18=24,0x4f=79
   int     10h                     ; int 10h

   ; 输出字符串:MBR
   mov byte [gs:0x00],'1'
   mov byte [gs:0x01],0xA4

   mov byte [gs:0x02],' '
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],'M'
   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色

   mov byte [gs:0x06],'B'
   mov byte [gs:0x07],0xA4

   mov byte [gs:0x08],'R'
   mov byte [gs:0x09],0xA4
	 
   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址
   mov bx,LOADER_BASE_ADDR       ; 写入的地址
   mov cx,1			 ; 待读入的扇区数
   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）
  
   jmp LOADER_BASE_ADDR
       
;-------------------------------------------------------------------------------
;功能:读取硬盘n个扇区
rd_disk_m_16:	   
;-------------------------------------------------------------------------------
				       ; eax=LBA扇区号
				       ; ebx=将数据写入的内存地址
				       ; ecx=读入的扇区数
      mov esi,eax	  ;备份eax
      mov di,cx		  ;备份cx
;读写硬盘:
;第1步：设置要读取的扇区数
      mov dx,0x1f2
      mov al,cl
      out dx,al            ;读取的扇区数

      mov eax,esi	   ;恢复ax

;第2步：将LBA地址存入0x1f3 ~ 0x1f6

      ;LBA地址7~0位写入端口0x1f3
      mov dx,0x1f3                       
      out dx,al                          

      ;LBA地址15~8位写入端口0x1f4
      mov cl,8
      shr eax,cl ;逻辑
      mov dx,0x1f4
      out dx,al

      ;LBA地址23~16位写入端口0x1f5
      shr eax,cl
      mov dx,0x1f5
      out dx,al

      shr eax,cl
      and al,0x0f	   ;lba第24~27位
      or al,0xe0	   ; 设置7～4位为1110,表示lba模式
      mov dx,0x1f6
      out dx,al

;第3步：向0x1f7端口写入command读命令，0x20 
      mov dx,0x1f7
      mov al,0x20                        
      out dx,al

;第4步：检测硬盘状态
  .not_ready:
      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
      nop ; 空转一点点时间,什么也不干
      in al,dx
      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
      cmp al,0x08
      jnz .not_ready	   ;若未准备好，继续等。

;第5步：从0x1f0端口读数据
      mov ax, di  ; 一次读取16位2B
      mov dx, 256 ;一个扇区有512B所以要读256次
      mul dx
      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，
			   ; 共需di*512/2次，所以di*256
      mov dx, 0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax ;把读出的数据放到loader初始位置然后开始偏移 注意!!这里简写[bx],其实是默认[ds:bx],以ds=0xF000为段基址寄存器
      add bx,2		  
      loop .go_on_read
      ret ; ret指令跳转

   times 510-($-$$) db 0
   db 0x55,0xaa

```

loader.s

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR

; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		       ; 通过死循环使程序悬停在此

```

![image-20230612211633006](assets/image-20230612211633006.png)



-------

## 四

> 实模式切入保护模式
>

![在这里插入图片描述](https://img-blog.csdnimg.cn/bce23a80eadf412382ae4bb45fb210cd.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/b7b8392f715a4b9bb511035e33506101.png)



> 代码loader.S剖析：



**1、代码功能**

启动保护模式后利用初始化的GDT表中的显存段描述符来对显存寻址后操作以显示字符

**2、实现原理**

IA32体系架构为了兼容8086，所以支持实模式，同时用保护模式提供更大的CPU寻址能力与访问安全性检查。刚开启电脑时，工作在实模式下。后面为了使用更好的性能而进入保护模式后，段基址寄存器的值不再作为实模式下的段基址，而是作为一个选择子，去GDT表中查询对应的段描述符以获得段基址与进行安全性检查，配合偏移来获得真实物理地址。

**3、代码逻辑（核心）**

A、初始化GDT表（就是定义要用到的段描述符）

B、利用BIOS中断打印字符串

C、打开保护模式，加载GDT表的基址进入GDTR寄存器

D、刷新流水线

E、加载显存段选择子，在保护模式下操作显存来显示字符

**4、怎么写代码？**

A、%include “boot.inc”；指定vstart=0x900；jmp到loader的可执行代码中去（因为loader中定义的GDT段描述符数据就直接会放在loader开头，而MBR最后会跳转到本程序开头来，数据不能被执行，我们要跳过它们）

B、利用已经在boot.inc中写好的模块化段描述符字段来拼凑出我们需要的代码段、数据段、显存段的段描述符。同时GDT表的第0项是全0，还要预留一些段描述符；然后定义显存段的选择子

C、查询BIOS中断打印字符串"2 loader in real"

D、开启保护模式：1、打开A20地址线（原因是因为8086存在高端内存，这部分内存只在逻辑中存在，物理中并没有对应。由于8086只有20根地址线，所以访问高端内存会自动丢掉最高位，所以并没有问题，当时很多程序员就利用这个特性偷懒。但是当后续CPU多了地址线后，之前8086偷懒程序员写的程序就会真的访问对于8086来说的高端内存。所以为了兼容他们的程序，就用A20地址线来控制是否能够访问更多的内存。用in与out指令就能与A20交互）；2、加载GDT表的首地址进入GDTR；3、将CR0寄存器的pe位置为1，意为打开保护模式（mov指令即可）

E、通过远跳转来刷新流水线

F、加载显存段选择子，切换32位编译，然后向显存段内存入数据来显示字符’P’

boot.inc

```assembly
                                                    ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中

```



loader.s

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是一大堆GDT段描述符数据，无法执行，所以要跳过
   
                                                        
GDT_BASE:                                               ;构建gdt及其内部的描述符
    dd 0x00000000 ;define double 定义四字节的0
	dd 0x00000000 ;所以GDT表的第0项为全0

CODE_DESC:  
    dd 0x0000FFFF ;低十六位是全1 高十六位是全0
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	 ;段基址的低十六位+段界限十六位                                   ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE ;$为本行地址
    GDT_LIMIT equ GDT_SIZE - 1 ;指定GDT表的界限
    times 60 dq 0	;define quadra 定义4字即8字节数据				                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:

                                                        ;------------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串
                                                        ;------------------------------------------------------------
                                                        ;输入:
                                                        ;AH 子功能号=13H
                                                        ;BH = 页码
                                                        ;BL = 属性(若AL=00H或01H)
                                                        ;CX＝字符串长度
                                                        ;(DH、DL)＝坐标(行、列)
                                                        ;ES:BP＝字符串地址 
                                                        ;AL＝显示输出方式
                                                        ;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变
                                                        ;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变
                                                        ;   2——字符串中含显示字符和显示属性。显示后，光标位置不变
                                                        ;   3——字符串中含显示字符和显示属性。显示后，光标位置改变
                                                        ;无返回值
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    ; ES:BP = 字符串地址
    mov	cx,17			                                ; CX = 字符串长度
    mov	ax,0x1301		                                ; AH = 13,  AL = 01h
    mov	bx,0x001f		                                ; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)
    mov	dx,0x1800		                                ;
    int	0x10                                            ; 10h 号中断

                                                        ;-----------------   准备进入保护模式   ------------------------------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1
                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;-----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax
                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $


```



> 命令

loader 615B

mbr	 512B

写loader入硬盘 要把count改成4,直接一步到位,因为这个时候loader已经超过512B了。

而且`dd`命令有个特性,你的`count`写的多大也好他会自己判断你本身文件的大小,所以说你的`count`写上一千一万都没事

`dd if=./loader.bin of=./hd60M.img bs=512 count=3 seek=2 conv=notrunc`

编译后，我们发现loader的大小已经超过我们的之前写的MBR设定加载的512B，所以我们修改MBR相关字段（修改与硬盘打交道7步骤中的第1步读取扇区数放入cx中的值，为了后面方便我们都改成4）

boot/mbr.S

```assembly
mov cx,4			            ; 待读入的扇区数
```
<img src="assets/image-20230516133737090.png" alt="image-20230516133737090" style="zoom: 80%;" />

![image-20230612211610567](assets/image-20230612211610567.png)







## 五

> 利用BIOS中断0x15子功能获取内存并进行内存容量检测

1. 内存容量检测

​		BIOS 0x15 中断把要调用的功能指定放在寄存器ax中，因此子功能号要存放到寄存器 EAX 或 AX 中，如下：

- EAX=0xE820：遍历主机上全部内存。返回的是内存布局，信息量多一些。

- AX =0xE801 : 分别检测低1MB和 16MB～4GB 的内存，最大支持 4GB。
- AH=0x88 ：最多检测出 64MB 内存，实际内存超过此容量也按64MB 返回。

![image-20230518111010714](assets/image-20230518111010714.png)

剖析loader.S代码：

**1、代码功能（核心）**

获取内存总容量

**2、实现原理（核心）**

在实模式下调用BIOS中断获得内存容量，然后将信息存储在内存中

**3、代码逻辑（核心）**

A、调用BIOS中断0x15子功能0xe820获取内存总容量，若不成功则跳至B

B、调用BIOS中断0x15子功能0xe801获取内存总容量，若不成功则跳至C

C、调用BIOS中断0x15子功能0x88获取内存总容量

**4、怎么写代码？（核心）**

注：在第4章最后一版loader.S基础之上（进入保护模式前）加获取内存容量的代码

A、按照BIOS中断返回类型的数据结构来开辟内存空间来存储中断获取到的信息

B、查询中断使用用法(书p178)，调用BIOS中断0x15子功能0xe820获得内存的ARDS结构体，不调用0xe801与0x88中断（懒）

C、遍历获得的ARDS结构体，将所有结构体中的BaseAddrLow与LengthLow相加，冒泡选择值最大的就是内存的大小



boot/loader.s

删除*/boot/loader.S* 的[jmp](https://so.csdn.net/so/search?q=jmp&spm=1001.2101.3001.7020)指令，

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR

  
GDT_BASE:                                               ;构建gdt及其内部的描述符
    dd 0x00000000 ;define double 定义四字节的0
	dd 0x00000000 ;所以GDT表的第0项为全0

CODE_DESC:  
    dd 0x0000FFFF ;低十六位是全1 高十六位是全0
	dd DESC_CODE_HIGH4

DATA_STACK_DESC:  
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC: 
    dd 0x80000007	 ;段基址的低十六位+段界限十六位                                   ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE ;$为本行地址
    GDT_LIMIT equ GDT_SIZE - 1 ;指定GDT表的界限
    times 60 dq 0	;define quadra 定义4字即8字节数据				                    ; 此处预留60个描述符的空间
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 


total_mem_bytes dd 0				                    ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
                                                        ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
                                                        ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址	
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
	    
ards_buf times 244 db 0                                 ;人工对齐total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
ards_nr dw 0		                                    ;用于记录ards结构体数量


loader_start:
                                                        ;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

    xor ebx, ebx		                                ;第一次调用时，ebx值要为0
    mov edx, 0x534d4150	                                ;edx只赋值一次，循环体中不会改变
    mov di, ards_buf	                                ;ards结构缓冲区
.e820_mem_get_loop:	                                ;循环获取每个ARDS内存范围描述结构
    mov eax, 0x0000e820	                                ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
    mov ecx, 20		                                    ;ARDS地址范围描述符结构大小是20字节
    int 0x15
    add di, cx		                                    ;使di增加20字节指向缓冲区中新的ARDS结构位置
    inc word [ards_nr]	                                ;记录ARDS数量 
    cmp ebx, 0		                                    ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
    jnz .e820_mem_get_loop

                                                        ;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
    mov cx, [ards_nr]	                                ;遍历每一个ARDS结构体,循环次数是ARDS的数量
    mov ebx, ards_buf  ; 取出ards的地址
    xor edx, edx		                                ;edx为最大的内存容量,在此先清0
.find_max_mem_area:	                                    ;无须判断type是否为1,最大的内存块一定是可被使用
    mov eax, [ebx]	     ;取出来地址的第一部分                               ;base_add_low
    add eax, [ebx+8]	                                ;length_low
    add ebx, 20		                                    ;指向缓冲区中下一个ARDS结构
    cmp edx, eax		                                ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量
    jge .next_ards
    mov edx, eax		                                ;edx为总内存大小
.next_ards:
    loop .find_max_mem_area

    mov [total_mem_bytes], edx	                        ;将内存换为byte单位后存入total_mem_bytes处。


;-----------------   准备进入保护模式   ------------------------------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1
                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;-----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax
    
                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。
.error_hlt:		                                        ;出错则挂起
    hlt


[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $

```



bin/mbr.s

修改**myos/boot/mbr.S** 的[jmp](https://so.csdn.net/so/search?q=jmp&spm=1001.2101.3001.7020)指令，跳转位置 + 0x300，使之能跳转至loader.S中的loader_start

```assembly
   jmp LOADER_BASE_ADDR + 0x300
```

```assembly
;主引导程序 
;------------------------------------------------------------
%include "boot.inc"
SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00
   mov ax,0xb800
   mov gs,ax

; 清屏
;利用0x06号功能，上卷全部行，则可清屏。
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷的行数(如果为0,表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值：
   mov     ax, 0600h
   mov     bx, 0700h
   mov     cx, 0                   ; 左上角: (0, 0)
   mov     dx, 184fh		   ; 右下角: (80,25),
				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				   ; 下标从0开始，所以0x18=24,0x4f=79
   int     10h                     ; int 10h

   ; 输出字符串:MBR
   mov byte [gs:0x00],'1'
   mov byte [gs:0x01],0xA4

   mov byte [gs:0x02],' '
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],'M'
   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色

   mov byte [gs:0x06],'B'
   mov byte [gs:0x07],0xA4

   mov byte [gs:0x08],'R'
   mov byte [gs:0x09],0xA4
	 
   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址
   mov bx,LOADER_BASE_ADDR       ; 写入的地址
   mov cx,4			 ; 待读入的扇区数
   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）
  
   jmp LOADER_BASE_ADDR + 0x300
       
;-------------------------------------------------------------------------------
;功能:读取硬盘n个扇区
rd_disk_m_16:	   
;-------------------------------------------------------------------------------
				       ; eax=LBA扇区号
				       ; ebx=将数据写入的内存地址
				       ; ecx=读入的扇区数
      mov esi,eax	  ;备份eax
      mov di,cx		  ;备份cx
;读写硬盘:
;第1步：设置要读取的扇区数
      mov dx,0x1f2
      mov al,cl
      out dx,al            ;读取的扇区数

      mov eax,esi	   ;恢复ax

;第2步：将LBA地址存入0x1f3 ~ 0x1f6

      ;LBA地址7~0位写入端口0x1f3
      mov dx,0x1f3                       
      out dx,al                          

      ;LBA地址15~8位写入端口0x1f4
      mov cl,8
      shr eax,cl
      mov dx,0x1f4
      out dx,al

      ;LBA地址23~16位写入端口0x1f5
      shr eax,cl
      mov dx,0x1f5
      out dx,al

      shr eax,cl
      and al,0x0f	   ;lba第24~27位
      or al,0xe0	   ; 设置7～4位为1110,表示lba模式
      mov dx,0x1f6
      out dx,al

;第3步：向0x1f7端口写入读命令，0x20 
      mov dx,0x1f7
      mov al,0x20                        
      out dx,al

;第4步：检测硬盘状态
  .not_ready:
      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
      nop
      in al,dx
      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
      cmp al,0x08
      jnz .not_ready	   ;若未准备好，继续等。

;第5步：从0x1f0端口读数据
      mov ax, di
      mov dx, 256
      mul dx
      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，
			   ; 共需di*512/2次，所以di*256
      mov dx, 0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax
      add bx,2		  
      loop .go_on_read
      ret

   times 510-($-$$) db 0
   db 0x55,0xaa

```

![image-20230613115710591](assets/image-20230613115710591.png)

按`ctrl+shift+c`暂停,然后`xp 0xb00`(exam print)

功能: 打印该地址的数据,一次性打印4B(32bits)数据

![image-20230613115953190](assets/image-20230613115953190.png)





-----

## 六

> 分页机制

### 建立分页

分段模型最大的缺点就是每个段大小不一，带来内存管理的困难（例子查看书P186）。所以需要通过固定大小且比一般段更小的块管理来代替原有的段管理，这就引出了分页机制。而且正是由于分页机制的引入，原有CPU设计者所设想的那种分段机制就基本被弃用，如现代操作系统都用平坦模型，抛弃了原来的那种在内存中分段管理的思路。

分页机制的核心就是，将程序所要用的虚拟内存空间（也就是32位编程时给程序分配的空间）与实际用到的内存空间分离。将程序所要用到的虚拟内存空间，拆分成一个个固定大小的小块（虚拟的，4K），与物理内存上的固定大小的小块建立映射关系。就是这样的一种分离，带来了内存管理的粒度更小（原有的段机制下段可能远比4K大得多）、粒度更标准（段大小不一，现在统一成了4K大小）、更灵活（将程序暂时用不到的小块不放入内存中，等用到了再从磁盘中调入）等优点。

![在这里插入图片描述](https://img-blog.csdnimg.cn/369c3af66a1245eb8aac907a207bdaf1.png)

为了向前兼容，之前段机制无法绕过（硬件决定好了要更大的寻址空间就必须要开启保护模式（段机制）），所以这分页机制只能在原有的段机制下开启。原有段机制得到的地址被重新命名为线性地址，需要经过页机制的处理得到物理地址，具体做法就是用段机制下得到的线性地址查询页表找到内存上的页。

![在这里插入图片描述](https://img-blog.csdnimg.cn/b88dbac74e8d4edf8f23a0538f59d6bf.png)



为了平衡管理整个进程（页表是以进程为单位分配）的页表的表项数量与整个页表大小的关系，最终选择了一个页表1M项，整个页表4MB（一个表项4B）。由于页表管理的是整个进程的虚拟地址空间，所以4GB内存大小（32位程序编程时，程序员都是按照可以完全使用4GB内存来编写，只不过这种完全式的使用根本不会真的给它，所以这个4GB内存空间实际上是虚拟的）对应1M表项的话，那么一个表项就管理4KB大小的虚拟地址空间。

为什么每个进程都需要独立的页表？其根本原因是32位程序编程时，程序员都是按照可以独占使用4GB内存编写，所以每个进程都想完全使用4GB内存。如果要用一个页表统一管理所有进程，那么就必须要有可以管理N（程序数量）*4GB内存空间的页表，但这页表对应的内存不可能有这么大。且这么大的内存出现后，之后的程序编程就会按照可以这么大的内存做基础，这又需要管理N*大于4GB的页表，然后循环…所以只能采取每个进程使用独立的页表，让他们假装可以使用4GB内存，然后再用某种机制只分配给他们“够用”的内存，而非4GB完全内存。这样的话，所有进程的页表所占总空间就是N（程序数量） *4MB，这又是一个不小的开销。所以采用二级页表的做法，让一级页表只有1024个页表项（每个页表项管理4MB空间，一级页表开销4KB），一级页表1024个页表项对应1024个二级页表，每个二级页表管理着4MB空间，然后每个二级页表都有1024个表项，每个二级页表表项管理着4KB的空间。当程序用到某4MB空间时候，才会为它建立对应的二级页表。这就达到了节省页表开销空间的目的。

分段机制下产生的线性地址通过分页机制转换到真实物理地址查看书p194。

页目录项与页表项结构如下图：（各字段含义查看书P196）

![在这里插入图片描述](https://img-blog.csdnimg.cn/7b3f0d28769149309f9b0efc81f00cf6.png)

现在我们编写代码，进行一些页表的初始化工作：

> 剖析loader.S代码
>

**1、代码功能**

一些页表的初始化工作

**2、实现原理**

硬件层面本就提供了分页机制，我们只需要进行页表的一些初始化工作，然后开启分页机制（硬件层面）即可

**3、代码逻辑（核心）**

A、将页目录表位置预留出来（创建0）

B、初始化一个页目录表（一级页表）

C、初始化第一个页表（二级页表）

**4、怎么写代码？**

A、先在boot.inc中定义页目录表的起始位置（放在内存1MB开始的位置），与定义模块化的页目录项与页表项字段；在上一版所写的loader.S中加入我们的创建页表函数。

B、在页目录表的位置初始化0。

C、页目录表0号项与768号项均指向第一个页表——0号项指向第一个页表（loader这个程序会运行在0-4M空间内，且跨越了段机制与页机制，顺序映射（第一个页表映射0开始4MB，第二个页表映射紧挨着下一个4MB空间）可以保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致，在这4M空间内，分段下的线性地址=分页后的虚拟地址=物理地址），768号项指向第一个页表是为了让分页机制下3GB开始的4MB虚拟地址空间（虚拟地址0-3G空间用户用，3-4G空间操作系统用）对应到了0-4M实际物理空间，因为这里放着我们的操作系统。这是为了所有进程共享操作系统做准备。页目录表最后一项1023号项指向自己——为的是将来动态操作页表做准备（后面章节会详细讲到）。

D、初始化第一个页表（非页目录表）——因为这个页表管理着0—4M的物理地址空间，我们的操作系统就在这个空间内。

E、初始化页目录表769号-1022号项，769号项指向第二个页表（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推，——为将来用户进程做准备，使所有用户进程共享内核空间（从768号项—1022号项的页目录表项会被拷贝到所有用户进程的页目录表项中）；

**boot.inc中加入如下代码 (include/boot.inc)**

```assembly
PAGE_DIR_TABLE_POS equ 0x100000                     ;页目录表在内存中的起始位置——从1M开始的位置

                                                    ;---------模块化的页目录表字段,PWT PCD A D G AVL 暂时不用设置   ----------
PG_P  equ   1b
PG_RW_R	 equ  00b 
PG_RW_W	 equ  10b 
PG_US_S	 equ  000b 
PG_US_U	 equ  100b  
```

**boot/loader.s**	加入setup_page代码段

```assembly
setup_page:                                             ;------------------------------------------   创建页目录及页表  -------------------------------------
                                                        ;----------------以下6行是将1M开始的4KB置为0，将页目录表初始化
    mov ecx, 4096                                       ;创建4096个byte 0，循环4096次
    mov esi, 0                                          ;用esi来作为偏移量寻址
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS + esi], 0
    inc esi
    loop .clear_page_dir

                                                        ; ----------------初始化页目录表，让0号项与768号指向同一个页表，该页表管理从0开始4M的空间
.create_pde:				                            ;一个页目录表项可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，这是为将地址映射为内核地址做准备
    mov eax, PAGE_DIR_TABLE_POS                         ; eax中存着页目录表的位置
    add eax, 0x1000 			                        ; 在页目录表位置的基础上+4K（页目录表的大小），现在eax中第一个页表的起始位置
    mov ebx, eax				                        ; 此处为ebx赋值，现在ebx存着第一个页表的起始位置
    or eax, PG_US_U | PG_RW_W | PG_P	                ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
                                                        ; 现在eax中的值符合一个页目录项的要求了，高20位是一个指向第一个页表的4K整数倍地址，低12位是相关属性设置
    mov [PAGE_DIR_TABLE_POS + 0x0], eax                 ; 页目录表0号项写入第一个页表的位置(0x101000)及属性(7)
    mov [PAGE_DIR_TABLE_POS + 0xc00], eax               ; 页目录表768号项写入第一个页表的位置(0x101000)及属性(7)
					                                    
    sub eax, 0x1000                                     ;----------------- 使最后一个目录项指向页目录表自己的地址，为的是将来动态操作页表做准备
    mov [PAGE_DIR_TABLE_POS + 4092], eax	            ;属性包含PG_US_U是为了将来init进程（运行在用户空间）访问这个页目录表项
                                                        
    mov ecx, 256				                        ; -----------------初始化第一个页表，因为我们的操作系统不会超过1M，所以只用初始化256项
    mov esi, 0                                          ; esi来做寻址页表项的偏移量
    xoe edx, edx                                        ;将edx置为0，现在edx指向0地址
    mov edx, PG_US_U | PG_RW_W | PG_P	                ; 属性为7,US=1,RW=1,P=1
.create_pte:				                            ; 创建Page Table Entry
    mov [ebx+esi*4],edx			                        ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
    add edx,4096                                        ; edx指向下一个4kb空间，且已经设定好了属性，故edx中是一个完整指向下一个4kb物理空间的页表表项
    inc esi                                             ; 寻址页表项的偏移量+1
    loop .create_pte                                    ;循环设定第一个页表的256项

                                                        ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推
    mov eax, PAGE_DIR_TABLE_POS                         ; eax存页目录表的起始位置
    add eax, 0x2000 		                            ; 此时eax为第二个页表的位置
    or eax, PG_US_U | PG_RW_W | PG_P                    ; 设置页目录表项相关属性，US,RW和P位都为1，现在eax中的值是一个完整的指向第二个页表的页目录表项
    mov ebx, PAGE_DIR_TABLE_POS                         ; ebx现在存着页目录表的起始位置
    mov ecx, 254			                            ; 要设置254个表项
    mov esi, 769                                        ; 要设置的页目录表项的偏移起始
.create_kernel_pde:
    mov [ebx+esi*4], eax                                ; 设置页目录表项
    inc esi                                             ; 增加要设置的页目录表项的偏移
    add eax, 0x1000                                     ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项
    loop .create_kernel_pde                             ; 循环设定254个页目录表项
    ret
```

----

### 插入字符

进行完初始化部分页目录表与页表工作之后，我们现在就要正式开启页机制了。我们之前已经将我们操作系统实际所在的物理地址空间0——4M与虚拟地址空间3G开始4M建立了映射关系，所以我们访问虚拟地址空间3G开始的4M空间，实际上访问的是物理地址空间0——4M，也就是我们的操作系统。

在分页机制下，我们现在要让访问物理0——4M空间的用户进程代码去访问3G开始的4M虚拟地址空间，这是为了将虚拟地址空间0——3G给应用进程使用（我们上面代码中页目录表的768-1022号项会拷贝到所有进程的页目录表中，不会拷贝0号项）。我们之前在分段机制下是通过选择子的方式查找GDT表中的段描述符来访问物理地址，所以我们需要通过修改GDT表中的段描述符实现上述重定位访问。同时由于访问GDT表不是通过GDT表中的段描述符，而是通过GDTR中的值，所以我们也需要修改GDTR中的值，让进程通过GDTR中的值找GDT的时候不是去物理内存0——4M空间找，而是去虚拟地址3G开始的4M找（不修改的话，要想让GDT表正常工作，需要将用户进程自己的页目录表第0项与物理地址0——4M建立映射关系，此时GDTR中存储的GDT线性地址才能转换成正确的GDT物理地址）

> 剖析loader.S代码：
>

**1、代码功能**

开启页表机制，在页机制下显示一个字符

**2、实现原理**

操作系统是一个高度和硬件相关的程序，在硬件层面IA32体系就提供了页机制的支撑

**3、代码逻辑**

A、创建页目录表与第一个页表

B、GDT中的视频段描述符、GDT表基地址、栈指针地址升高

C、开启页机制

D、重载GDT表

E、操作显存段显示字符

**4、怎么写代码？**

A、调用之前写好的setup_page完成页目录表与页表的创建

B、GDT中的视频段描述符表地址+3G 、GDT表基地址+3G、栈指针地址+3G

C、开启页机制二步骤

将页目录表地址写入控制寄存器CR3
将CR0寄存器的PG位置为1
D、重新加载GDT地址

E、操作显存段显示字符



**boot/loader.s**中加入如下代码

```assembly
call setup_page                                     ;创建页目录表的函数,我们的页目录表必须放在1M开始的位置，所以必须在开启保护模式后运行

                                                    ;以下两句是将gdt描述符中视频段描述符中的段基址+0xc0000000
mov ebx, [gdt_ptr + 2]                              ;ebx中存着GDT_BASE
or dword [ebx + 0x18 + 4], 0xc0000000               ;视频段是第3个段描述符,每个描述符是8字节,故0x18 = 24，然后+4，是取出了视频段段描述符的高4字节。然后or操作，段基址最高位+c
                                       
add dword [gdt_ptr + 2], 0xc0000000                 ;将gdt的基址加上0xc0000000使其成为内核所在的高地址

add esp, 0xc0000000                                 ; 将栈指针同样映射到内核地址

mov eax, PAGE_DIR_TABLE_POS                         ; 把页目录地址赋给cr3
mov cr3, eax
                                                    
mov eax, cr0                                        ; 打开cr0的pg位(第31位)
or eax, 0x80000000  
mov cr0, eax
                                                  
lgdt [gdt_ptr]                                      ;在开启分页后,用gdt新的地址重新加载

mov byte [gs:160], 'V'                              ;视频段段基址已经被更新,用字符v表示virtual addr
```


-----

### 最终代码

**boot/loader.s**

```assembly
   %include "boot.inc"
   section loader vstart=LOADER_BASE_ADDR
   LOADER_STACK_TOP equ LOADER_BASE_ADDR
   
;构建gdt及其内部的描述符
   GDT_BASE:   dd    0x00000000 
	       dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
	       dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
		     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007	       ; limit=(0xbffff-0xb8000)/4k=0x7
	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

   GDT_SIZE   equ   $ - GDT_BASE
   GDT_LIMIT   equ   GDT_SIZE -	1 
   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)
   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	 ; 同上
   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	 ; 同上 

   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。
   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,
   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址
   total_mem_bytes dd 0					 
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
	    dd  GDT_BASE

   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节
   ards_buf times 244 db 0
   ards_nr dw 0		      ;用于记录ards结构体数量

   loader_start:
   
;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------

   xor ebx, ebx		      ;第一次调用时，ebx值要为0
   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变
   mov di, ards_buf	      ;ards结构缓冲区
.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构
   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。
   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节
   int 0x15
   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能
   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置
   inc word [ards_nr]	      ;记录ARDS数量
   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个
   jnz .e820_mem_get_loop

;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。
   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量
   mov ebx, ards_buf 
   xor edx, edx		      ;edx为最大的内存容量,在此先清0
.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用
   mov eax, [ebx]	      ;base_add_low
   add eax, [ebx+8]	      ;length_low
   add ebx, 20		      ;指向缓冲区中下一个ARDS结构
   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量
   jge .next_ards
   mov edx, eax		      ;edx为总内存大小
.next_ards:
   loop .find_max_mem_area
   jmp .mem_get_ok

;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------
; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位
; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。
.e820_failed_so_try_e801:
   mov ax,0xe801
   int 0x15
   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法

;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位
   mov cx,0x400	     ;cx和ax值一样,cx用做乘数
   mul cx 
   shl edx,16
   and eax,0x0000FFFF
   or edx,eax
   add edx, 0x100000 ;ax只是15MB,故要加1MB
   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份

;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量
   xor eax,eax
   mov ax,bx		
   mov ecx, 0x10000	;0x10000十进制为64KB
   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.
   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可
   mov edx,esi		;edx为总内存大小
   jmp .mem_get_ok

;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------
.e801_failed_so_try88: 
   ;int 15后，ax存入的是以kb为单位的内存容量
   mov  ah, 0x88
   int  0x15
   jc .error_hlt
   and eax,0x0000FFFF
      
   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中
   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位
   mul cx
   shl edx, 16	     ;把dx移到高16位
   or edx, eax	     ;把积的低16位组合到edx,为32位的积
   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB

.mem_get_ok:
   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。


;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1

   ;-----------------  打开A20  ----------------
   in al,0x92
   or al,0000_0010B
   out 0x92,al

   ;-----------------  加载GDT  ----------------
   lgdt [gdt_ptr]

   ;-----------------  cr0第0位置1  ----------------
   mov eax, cr0
   or eax, 0x00000001
   mov cr0, eax

   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。
.error_hlt:		      ;出错则挂起
   hlt

[bits 32]
p_mode_start:
   mov ax, SELECTOR_DATA
   mov ds, ax
   mov es, ax
   mov ss, ax
   mov esp,LOADER_STACK_TOP
   mov ax, SELECTOR_VIDEO
   mov gs, ax

   ; 创建页目录及页表并初始化页内存位图
   call setup_page

   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载
   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置

   ;将gdt描述符中视频段描述符中的段基址+0xc0000000
   mov ebx, [gdt_ptr + 2]  
   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。
					      ;段描述符的高4字节的最高位是段基址的31~24位

   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址
   add dword [gdt_ptr + 2], 0xc0000000

   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址

   ; 把页目录地址赋给cr3
   mov eax, PAGE_DIR_TABLE_POS
   mov cr3, eax

   ; 打开cr0的pg位(第31位)
   mov eax, cr0
   or eax, 0x80000000
   mov cr0, eax

   ;在开启分页后,用gdt新的地址重新加载
   lgdt [gdt_ptr]             ; 重新加载

   mov byte [gs:160], 'V'     ;视频段段基址已经被更新,用字符v表示virtual addr

   jmp $

;-------------   创建页目录及页表   ---------------
setup_page:
;先把页目录占用的空间逐字节清0
   mov ecx, 4096
   mov esi, 0
.clear_page_dir:
   mov byte [PAGE_DIR_TABLE_POS + esi], 0
   inc esi
   loop .clear_page_dir

;开始创建页目录项(PDE)
.create_pde:				     ; 创建Page Directory Entry
   mov eax, PAGE_DIR_TABLE_POS
   add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性
   mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。

;   下面将页目录项0和0xc00都存为第一个页表的地址，
;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，
;   这是为将地址映射为内核地址做准备
   or eax, PG_US_U | PG_RW_W | PG_P	     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)
   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,
					     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.
   sub eax, 0x1000
   mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址

;下面创建页表项(PTE)
   mov ecx, 256				     ; 1M低端内存 / 每页大小4k = 256
   mov esi, 0
   mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US=1,RW=1,P=1
.create_pte:				     ; 创建Page Table Entry
   mov [ebx+esi*4],edx			     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
   add edx,4096
   inc esi
   loop .create_pte

;创建内核其它页表的PDE
   mov eax, PAGE_DIR_TABLE_POS
   add eax, 0x2000 		     ; 此时eax为第二个页表的位置
   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性US,RW和P位都为1
   mov ebx, PAGE_DIR_TABLE_POS
   mov ecx, 254			     ; 范围为第769~1022的所有目录项数量
   mov esi, 769
.create_kernel_pde:
   mov [ebx+esi*4], eax
   inc esi
   add eax, 0x1000
   loop .create_kernel_pde
   ret
```



**boot/mbr.s**不变



**include/boot.inc**

```assembly
;-------------	 loader和kernel   ----------

LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
KERNEL_BIN_BASE_ADDR equ 0x70000
KERNEL_IMAGE_BASE_ADDR  equ   0x1500
KERNEL_START_SECTOR equ 0x9

PAGE_DIR_TABLE_POS equ 0x100000

;--------------   gdt描述符属性  -------------
DESC_G_4K   equ	  1_00000000000000000000000b   
DESC_D_32   equ	   1_0000000000000000000000b
DESC_L	    equ	    0_000000000000000000000b	;  64位代码标记，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	;  cpu不用此位，暂置为0  
DESC_LIMIT_CODE2  equ 1111_0000000000000000b
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b
DESC_P	    equ		  1_000000000000000b
DESC_DPL_0  equ		   00_0000000000000b
DESC_DPL_1  equ		   01_0000000000000b
DESC_DPL_2  equ		   10_0000000000000b
DESC_DPL_3  equ		   11_0000000000000b
DESC_S_CODE equ		     1_000000000000b
DESC_S_DATA equ	  DESC_S_CODE
DESC_S_sys  equ		     0_000000000000b
DESC_TYPE_CODE  equ	      1000_00000000b	;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.

DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

;--------------   选择子属性  ---------------
RPL0  equ   00b
RPL1  equ   01b
RPL2  equ   10b
RPL3  equ   11b
TI_GDT	 equ   000b
TI_LDT	 equ   100b


;----------------   页表相关属性    --------------
PG_P  equ   1b
PG_RW_R	 equ  00b 
PG_RW_W	 equ  10b 
PG_US_S	 equ  000b 
PG_US_U	 equ  100b 
```

> 命令

- `nasm -I include/ -o mbr.bin mbr.s`
-  `dd if=./mbr.bin of=./hd60M.img bs=512 count=1 conv=notrunc`

-  `nasm -I include/ -o loader.bin loader.s`
- `dd if=./loader.bin of=./hd60M.img bs=512 count=4 seek=2 conv=notrunc`
-  `../bin/bochs -f bochsrc.disk`

> 效果图

![image-20230613183335847](assets/image-20230613183335847.png)

-----



